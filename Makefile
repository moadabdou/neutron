# Detect the operating system\nUNAME_S := $(shell uname -s)\n\nSRCDIR = src\nINCDIR = include\nBUILDDIR = build\nBOXDIR = box\nTARGET = neutron\n\n# Set appropriate compiler and flags based on OS\nifeq ($(UNAME_S),Darwin)\n    # macOS settings\n    CXX = clang++\n    SHARED_EXT = .dylib\n    SHARED_FLAGS = -dynamiclib\n    RTLDYNAMIC_FLAG = \n    # Find jsoncpp library path\n    ifeq (,$(wildcard /opt/homebrew/lib/libjsoncpp.dylib))\n        ifeq (,$(wildcard /usr/local/lib/libjsoncpp.dylib))\n            JSONLIB = -ljsoncpp\n        else\n            JSONLIB = -L/usr/local/lib -ljsoncpp\n            DEPENDENCIES += -I/usr/local/include\n        endif\n    else\n        JSONLIB = -L/opt/homebrew/lib -ljsoncpp\n        DEPENDENCIES += -I/opt/homebrew/include\n    endif\nelse\n    # Linux settings\n    CXX = g++\n    SHARED_EXT = .so\n    SHARED_FLAGS = -shared -rdynamic\n    RTLDYNAMIC_FLAG = -rdynamic\n    JSONLIB = -ljsoncpp\nendif\n\nLIBTARGET = libneutron_runtime$(SHARED_EXT)\n\nSRCS = $(shell find src -type f -name \"*.cpp\" ! -name \"main.cpp\" ! -name \"bytecode_runner.cpp\")\nLIBSRCS = $(shell find libs -type f -name \"*.cpp\")\nBOXSRCS = $(shell find $(BOXDIR) -type f -name \"*.cpp\")\nOBJS = $(SRCS:src/%.cpp=build/%.o)\nLIBOBJS = $(LIBSRCS:libs/%.cpp=build/%.o)\nBOXOBJS = $(BOXSRCS:$(BOXDIR)/%.cpp=build/box/%.o)\nDEPENDENCIES = -I$(INCDIR) -I. -Ilibs/json -Ilibs/http -Ilibs/time -Ilibs/sys -I$(BOXDIR) -Ilibs/websocket\n\n# Default to release build\nDEBUG ?= 0\n\nifeq ($(DEBUG), 1)\n    CXXFLAGS = -std=c++17 -Wall -Wextra -g -O0 -DDEBUG_TRACE_EXECUTION -DDEBUG_PRINT_CODE -fPIC\nelse\n    CXXFLAGS = -std=c++17 -Wall -Wextra -O2 -fPIC\nendif\n\n.PHONY: all clean directories release\n\nall: directories $(TARGET) $(LIBTARGET)\n\nrelease:\n\t$(MAKE) all DEBUG=0\n\tstrip $(TARGET)\n\t@echo \"Release build complete. Binary located at ./$(TARGET)\"\n\ndirectories:\n\t@mkdir -p $(BUILDDIR)\n\t@mkdir -p $(BUILDDIR)/core\n\t@mkdir -p $(BUILDDIR)/json\n\t@mkdir -p $(BUILDDIR)/http\n\t@mkdir -p $(BUILDDIR)/time\n\t@mkdir -p $(BUILDDIR)/sys\n\t@mkdir -p $(BUILDDIR)/box\n\n$(LIBTARGET): $(OBJS) $(LIBOBJS)\n\t$(CXX) $(CXXFLAGS) $(SHARED_FLAGS) $(OBJS) $(LIBOBJS) -lcurl $(JSONLIB) -o $(LIBTARGET)\n\t@echo \"Runtime library created. Located at ./$(LIBTARGET)\"\n\n$(TARGET): $(OBJS) $(LIBOBJS) build/main.o\n\t$(CXX) $(CXXFLAGS) $(RTLDYNAMIC_FLAG) build/main.o $(OBJS) $(LIBOBJS) -lcurl $(JSONLIB) -o $(TARGET)\n\t@echo \"Compilation complete. Binary located at ./$(TARGET)\"\n\nbuild/%.o: src/%.cpp\n\t@mkdir -p $(@D)\n\t$(CXX) $(CXXFLAGS) $(DEPENDENCIES) -c $< -o $@\n\nbuild/%.o: libs/%.cpp\n\t@mkdir -p $(@D)\n\t$(CXX) $(CXXFLAGS) $(DEPENDENCIES) -c $< -o $@\n\nbuild/box/%.o: $(BOXDIR)/%.cpp\n\t@mkdir -p $(@D)\n\t$(CXX) $(CXXFLAGS) $(DEPENDENCIES) -c $< -o $@\n\nbuild/main.o: src/main.cpp\n\t@mkdir -p $(@D)\n\t$(CXX) $(CXXFLAGS) $(DEPENDENCIES) -c $< -o $@\n\n.PHONY: shared_libs\nshared_libs:\n\t@for dir in $(wildcard $(BOXDIR)/*); do \\\n\t\tif [ -f \"$dir/native.cpp\" ]; then \\\n\t\t\tmodule_name=`basename $$dir`; \\\n\t\t\techo \"Building shared library for $$module_name...\"; \\\n\t\t\t$(CXX) $(CXXFLAGS) $(SHARED_FLAGS) -fPIC $(DEPENDENCIES) $$dir/native.cpp -lcurl $(JSONLIB) -o $$dir/$$module_name$(SHARED_EXT); \\\n\t\t\techo \"Created shared library: $$dir/$$module_name$(SHARED_EXT)\"; \\\n\t\telif [ -f \"$dir/native.c\" ]; then \\\n\t\t\tmodule_name=`basename $$dir`; \\\n\t\t\t$(CXX) $(CXXFLAGS) $(SHARED_FLAGS) -fPIC $(DEPENDENCIES) $$dir/native.c -lcurl $(JSONLIB) -o $$dir/$$module_name$(SHARED_EXT); \\\n\t\t\techo \"Created shared library: $$dir/$$module_name$(SHARED_EXT)\"; \\\n\t\tfi \\\n\tdone\n\n\nclean:\n\trm -rf $(BUILDDIR) $(TARGET) $(LIBTARGET)\n\n# Rule to build individual box modules\n# Pattern: box/module_name/module_name.dylib\nbox/%/%.dylib:\n\t@modulename=$*; \\\n\techo \"Building box module: $modulename\"; \\\n\tif [ -f \"box/$modulename/native.cpp\" ]; then \\\n\t\t$(CXX) $(CXXFLAGS) $(SHARED_FLAGS) -fPIC $(DEPENDENCIES) box/$modulename/native.cpp -lcurl $(JSONLIB) -o box/$modulename/$modulename.dylib; \\\n\t\techo \"Created shared library: box/$modulename/$modulename.dylib\"; \\\n\telif [ -f \"box/$modulename/native.c\" ]; then \\\n\t\t$(CXX) $(CXXFLAGS) $(SHARED_FLAGS) -fPIC $(DEPENDENCIES) box/$modulename/native.c -lcurl $(JSONLIB) -o box/$modulename/$modulename.dylib; \\\n\t\techo \"Created shared library: box/$modulename/$modulename.dylib\"; \\\n\telse \\\n\t\techo \"Error: No native.c or native.cpp file found in box/$modulename\"; \\\n\t\texit 1; \\\n\tfi\n\n# Rule for Linux modules (if needed)\nbox/%/%.so:\n\t@modulename=$*; \\\n\techo \"Building box module: $modulename\"; \\\n\tif [ -f \"box/$modulename/native.cpp\" ]; then \\\n\t\t$(CXX) $(CXXFLAGS) $(SHARED_FLAGS) -fPIC $(DEPENDENCIES) box/$modulename/native.cpp -lcurl $(JSONLIB) -o box/$modulename/$modulename.so; \\\n\t\techo \"Created shared library: box/$modulename/$modulename.so\"; \\\n\telif [ -f \"box/$modulename/native.c\" ]; then \\\n\t\t$(CXX) $(CXXFLAGS) $(SHARED_FLAGS) -fPIC $(DEPENDENCIES) box/$modulename/native.c -lcurl $(JSONLIB) -o box/$modulename/$modulename.so; \\\n\t\techo \"Created shared library: box/$modulename/$modulename.so\"; \\\n\telse \\\n\t\techo \"Error: No native.c or native.cpp file found in box/$modulename\"; \\\n\t\texit 1; \\\n\tfi\n\ninstall:\n\tcp $(TARGET) /usr/local/bin/\n\nuninstall:\n\trm -f /usr/local/bin/$(TARGET)