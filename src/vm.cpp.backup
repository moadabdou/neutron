#include "vm.h"
#include <iostream>
#include <stdexcept>
#include <fstream>
#include <sstream>
#include "scanner.h"
#include "parser.h"
#include <cmath>

namespace neutron {

// RAII class to restore the environment
class EnvironmentGuard {
public:
    EnvironmentGuard(VM& vm, std::shared_ptr<Environment> previous)
        : vm(vm), previous(previous) {}

    ~EnvironmentGuard() {
        vm.environment = previous;
    }

private:
    VM& vm;
    std::shared_ptr<Environment> previous;
};

// Helper to check if a value is "truthy"
bool isTruthy(const Value& value) {
    if (value.type == ValueType::NIL) return false;
    if (value.type == ValueType::BOOLEAN) return value.as.boolean;
    return true; // All other types are truthy
}

Value::Value() : type(ValueType::NIL) { as.function = nullptr; }

Value::Value(std::nullptr_t) : type(ValueType::NIL) { as.function = nullptr; }

Value::Value(bool value) : type(ValueType::BOOLEAN) {
    as.boolean = value;
}

Value::Value(double value) : type(ValueType::NUMBER) {
    as.number = value;
}

Value::Value(const std::string& value) : type(ValueType::STRING) {
    as.string = new std::string(value);
}

Value::Value(Callable* function) : type(ValueType::FUNCTION) {
    as.function = function;
}

Value::Value(Module* module) : type(ValueType::MODULE) {
    as.module = module;
}

std::string Value::toString() const {
    switch (type) {
        case ValueType::NIL:
            return "nil";
        case ValueType::BOOLEAN:
            return as.boolean ? "true" : "false";
        case ValueType::NUMBER: {
            // Convert double to string, removing trailing zeros
            char buffer[32];
            snprintf(buffer, sizeof(buffer), "%.15g", as.number);
            return std::string(buffer);
        }
        case ValueType::STRING:
            return *as.string;
        case ValueType::OBJECT:
            return "<object>";
        case ValueType::FUNCTION:
            return as.function->toString();
        case ValueType::MODULE:
            return "<module>";
    }
    return "";
}

Environment::Environment() : enclosing(nullptr) {}

Environment::Environment(std::shared_ptr<Environment> enclosing) : enclosing(enclosing) {}

void Environment::define(const std::string& name, const Value& value) {
    values[name] = value;
}

Value Environment::get(const std::string& name) {
    auto it = values.find(name);
    if (it != values.end()) {
        return it->second;
    }

    if (enclosing != nullptr) {
        return enclosing->get(name);
    }

    throw std::runtime_error("Undefined variable '" + name + "'.");
}

void Environment::assign(const std::string& name, const Value& value) {
    auto it = values.find(name);
    if (it != values.end()) {
        values[name] = value;
        return;
    }

    if (enclosing != nullptr) {
        enclosing->assign(name, value);
        return;
    }

    throw std::runtime_error("Undefined variable '" + name + "'.");
}

Function::Function(const FunctionStmt* declaration, std::shared_ptr<Environment> closure)
    : declaration(declaration), closure(closure) {}

int Function::arity() {
    return declaration->params.size();
}

Value Function::call(VM& vm, std::vector<Value> arguments) {
    auto environment = std::make_shared<Environment>(closure);
    for (size_t i = 0; i < declaration->params.size(); ++i) {
        environment->define(declaration->params[i].lexeme, arguments[i]);
    }

    try {
        vm.executeBlock(declaration->body, environment);
    } catch (Return& returnValue) {
        return returnValue.value;
    }

    return Value(nullptr);
}

std::string Function::toString() {
    return "<fn " + declaration->name.lexeme + ">";
}

NativeFn::NativeFn(NativeFnPtr function, int arity) : function(function), _arity(arity) {}

int NativeFn::arity() {
    return _arity;
}

Value NativeFn::call(VM& /*vm*/, std::vector<Value> arguments) {
    return function(arguments);
}

std::string NativeFn::toString() {
    return "<native fn>";
}

Module::Module(std::string name, std::shared_ptr<Environment> environment)
    : name(name), environment(environment) {}

Value Module::get(const std::string& name) {
    return environment->get(name);
}

Value math_add(std::vector<Value> arguments) {
    if (arguments.size() != 2) {
        throw std::runtime_error("Expected 2 arguments for add().");
    }
    if (arguments[0].type != ValueType::NUMBER || arguments[1].type != ValueType::NUMBER) {
        throw std::runtime_error("Arguments for add() must be numbers.");
    }
    return Value(arguments[0].as.number + arguments[1].as.number);
}

Value math_subtract(std::vector<Value> arguments) {
    if (arguments.size() != 2) {
        throw std::runtime_error("Expected 2 arguments for subtract().");
    }
    if (arguments[0].type != ValueType::NUMBER || arguments[1].type != ValueType::NUMBER) {
        throw std::runtime_error("Arguments for subtract() must be numbers.");
    }
    return Value(arguments[0].as.number - arguments[1].as.number);
}

Value math_multiply(std::vector<Value> arguments) {
    if (arguments.size() != 2) {
        throw std::runtime_error("Expected 2 arguments for multiply().");
    }
    if (arguments[0].type != ValueType::NUMBER || arguments[1].type != ValueType::NUMBER) {
        throw std::runtime_error("Arguments for multiply() must be numbers.");
    }
    return Value(arguments[0].as.number * arguments[1].as.number);
}

Value math_divide(std::vector<Value> arguments) {
    if (arguments.size() != 2) {
        throw std::runtime_error("Expected 2 arguments for divide().");
    }
    if (arguments[0].type != ValueType::NUMBER || arguments[1].type != ValueType::NUMBER) {
        throw std::runtime_error("Arguments for divide() must be numbers.");
    }
    if (arguments[1].as.number == 0) {
        throw std::runtime_error("Division by zero.");
    }
    return Value(arguments[0].as.number / arguments[1].as.number);
}

Value math_pow(std::vector<Value> arguments) {
    if (arguments.size() != 2) {
        throw std::runtime_error("Expected 2 arguments for pow().");
    }
    if (arguments[0].type != ValueType::NUMBER || arguments[1].type != ValueType::NUMBER) {
        throw std::runtime_error("Arguments for pow() must be numbers.");
    }
    return Value(pow(arguments[0].as.number, arguments[1].as.number));
}

Value math_sqrt(std::vector<Value> arguments) {
    if (arguments.size() != 1) {
        throw std::runtime_error("Expected 1 argument for sqrt().");
    }
    if (arguments[0].type != ValueType::NUMBER) {
        throw std::runtime_error("Argument for sqrt() must be a number.");
    }
    return Value(sqrt(arguments[0].as.number));
}

Value math_abs(std::vector<Value> arguments) {
    if (arguments.size() != 1) {
        throw std::runtime_error("Expected 1 argument for abs().");
    }
    if (arguments[0].type != ValueType::NUMBER) {
        throw std::runtime_error("Argument for abs() must be a number.");
    }
    return Value(static_cast<double>(abs(arguments[0].as.number)));
}

Value math_sin(std::vector<Value> arguments) {
    if (arguments.size() != 1) {
        throw std::runtime_error("Expected 1 argument for sin().");
    }
    if (arguments[0].type != ValueType::NUMBER) {
        throw std::runtime_error("Argument for sin() must be a number.");
    }
    return Value(sin(arguments[0].as.number));
}

Value math_cos(std::vector<Value> arguments) {
    if (arguments.size() != 1) {
        throw std::runtime_error("Expected 1 argument for cos().");
    }
    if (arguments[0].type != ValueType::NUMBER) {
        throw std::runtime_error("Argument for cos() must be a number.");
    }
    return Value(cos(arguments[0].as.number));
}

Value math_tan(std::vector<Value> arguments) {
    if (arguments.size() != 1) {
        throw std::runtime_error("Expected 1 argument for tan().");
    }
    if (arguments[0].type != ValueType::NUMBER) {
        throw std::runtime_error("Argument for tan() must be a number.");
    }
    return Value(tan(arguments[0].as.number));
}

Value math_log(std::vector<Value> arguments) {
    if (arguments.size() != 1) {
        throw std::runtime_error("Expected 1 argument for log().");
    }
    if (arguments[0].type != ValueType::NUMBER) {
        throw std::runtime_error("Argument for log() must be a number.");
    }
    return Value(log(arguments[0].as.number));
}

Value math_exp(std::vector<Value> arguments) {
    if (arguments.size() != 1) {
        throw std::runtime_error("Expected 1 argument for exp().");
    }
    if (arguments[0].type != ValueType::NUMBER) {
        throw std::runtime_error("Argument for exp() must be a number.");
    }
    return Value(exp(arguments[0].as.number));
}

Value math_ceil(std::vector<Value> arguments) {
    if (arguments.size() != 1) {
        throw std::runtime_error("Expected 1 argument for ceil().");
    }
    if (arguments[0].type != ValueType::NUMBER) {
        throw std::runtime_error("Argument for ceil() must be a number.");
    }
    return Value(ceil(arguments[0].as.number));
}

Value math_floor(std::vector<Value> arguments) {
    if (arguments.size() != 1) {
        throw std::runtime_error("Expected 1 argument for floor().");
    }
    if (arguments[0].type != ValueType::NUMBER) {
        throw std::runtime_error("Argument for floor() must be a number.");
    }
    return Value(floor(arguments[0].as.number));
}

Value math_round(std::vector<Value> arguments) {
    if (arguments.size() != 1) {
        throw std::runtime_error("Expected 1 argument for round().");
    }
    if (arguments[0].type != ValueType::NUMBER) {
        throw std::runtime_error("Argument for round() must be a number.");
    }
    return Value(static_cast<double>(round(arguments[0].as.number)));
}

// Native primitive functions for string/char manipulation
Value native_char_to_int(std::vector<Value> arguments) {
    if (arguments.size() != 1 || arguments[0].type != ValueType::STRING || arguments[0].as.string->length() != 1) {
        throw std::runtime_error("Expected a single-character string argument for char_to_int().");
    }
    return Value(static_cast<double>((*arguments[0].as.string)[0]));
}

Value native_int_to_char(std::vector<Value> arguments) {
    if (arguments.size() != 1 || arguments[0].type != ValueType::NUMBER) {
        throw std::runtime_error("Expected an integer argument for int_to_char().");
    }
    return Value(std::string(1, static_cast<char>(arguments[0].as.number)));
}

Value native_string_get_char_at(std::vector<Value> arguments) {
    if (arguments.size() != 2 || arguments[0].type != ValueType::STRING || arguments[1].type != ValueType::NUMBER) {
        throw std::runtime_error("Expected string and integer arguments for string_get_char_at().");
    }
    std::string str = *arguments[0].as.string;
    int index = static_cast<int>(arguments[1].as.number);
    if (index < 0 || index >= static_cast<int>(str.length())) {
        throw std::runtime_error("String index out of bounds.");
    }
    return Value(std::string(1, str[index]));
}

Value native_string_length(std::vector<Value> arguments) {
    if (arguments.size() != 1 || arguments[0].type != ValueType::STRING) {
        throw std::runtime_error("Expected a string argument for string_length().");
    }
    return Value(static_cast<double>(arguments[0].as.string->length()));
}

VM::VM() : environment(std::make_shared<Environment>()) {
    auto math_env = std::make_shared<Environment>();
    math_env->define("add", Value(new NativeFn(math_add, 2)));
    math_env->define("subtract", Value(new NativeFn(math_subtract, 2)));
    math_env->define("multiply", Value(new NativeFn(math_multiply, 2)));
    math_env->define("divide", Value(new NativeFn(math_divide, 2)));
    math_env->define("pow", Value(new NativeFn(math_pow, 2)));
    math_env->define("sqrt", Value(new NativeFn(math_sqrt, 1)));
    math_env->define("abs", Value(new NativeFn(math_abs, 1)));
    math_env->define("sin", Value(new NativeFn(math_sin, 1)));
    math_env->define("cos", Value(new NativeFn(math_cos, 1)));
    math_env->define("tan", Value(new NativeFn(math_tan, 1)));
    math_env->define("log", Value(new NativeFn(math_log, 1)));
    math_env->define("exp", Value(new NativeFn(math_exp, 1)));
    math_env->define("ceil", Value(new NativeFn(math_ceil, 1)));
    math_env->define("floor", Value(new NativeFn(math_floor, 1)));
    math_env->define("round", Value(new NativeFn(math_round, 1)));

    auto math_module = new Module("math", math_env);
    environment->define("math", Value(math_module));

    auto convert_env = std::make_shared<Environment>();
    convert_env->define("char_to_int", Value(new NativeFn(native_char_to_int, 1)));
    convert_env->define("int_to_char", Value(new NativeFn(native_int_to_char, 1)));
    convert_env->define("string_get_char_at", Value(new NativeFn(native_string_get_char_at, 2)));
    convert_env->define("string_length", Value(new NativeFn(native_string_length, 1)));

    auto convert_module = new Module("convert", convert_env);
    environment->define("convert", Value(convert_module));
}

void VM::interpret(const std::vector<std::unique_ptr<Stmt>>& statements, std::shared_ptr<Environment> env) {
    std::shared_ptr<Environment> previous = this->environment;
    EnvironmentGuard guard(*this, previous);
    this->environment = env;

    try {
        for (const auto& stmt : statements) {
            execute(stmt.get());
        }
    } catch (Return& e) {
        std::cerr << "Runtime error: Cannot return from top-level code." << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Runtime error: " << e.what() << std::endl;
    }
}

void VM::execute(const Stmt* stmt) {
    // std::cout << "Executing statement type: " << static_cast<int>(stmt->type) << std::endl;
    switch (stmt->type) {
        case StmtType::EXPRESSION:
            visitExpressionStmt(static_cast<const ExpressionStmt*>(stmt));
            break;
        case StmtType::PRINT:
            visitPrintStmt(static_cast<const PrintStmt*>(stmt));
            break;
        case StmtType::VAR:
            visitVarStmt(static_cast<const VarStmt*>(stmt));
            break;
        case StmtType::BLOCK:
            visitBlockStmt(static_cast<const BlockStmt*>(stmt));
            break;
        case StmtType::IF:
            visitIfStmt(static_cast<const IfStmt*>(stmt));
            break;
        case StmtType::WHILE:
            visitWhileStmt(static_cast<const WhileStmt*>(stmt));
            break;
        case StmtType::IMPORT:
            visitImportStmt(static_cast<const ImportStmt*>(stmt));
            break;
        case StmtType::FUNCTION:
            visitFunctionStmt(static_cast<const FunctionStmt*>(stmt));
            break;
        case StmtType::RETURN:
            visitReturnStmt(static_cast<const ReturnStmt*>(stmt));
            break;
        case StmtType::CLASS:
            // TODO: Implement class statement visitation
            break;
    }
}

void VM::executeBlock(const std::vector<std::unique_ptr<Stmt>>& statements, std::shared_ptr<Environment> environment) {
    std::shared_ptr<Environment> previous = this->environment;
    EnvironmentGuard guard(*this, previous);
    this->environment = environment;

    for (const auto& statement : statements) {
        execute(statement.get());
    }
}

Value VM::evaluate(const Expr* expr) {
    switch (expr->type) {
        case ExprType::LITERAL:
            return visitLiteralExpr(static_cast<const LiteralExpr*>(expr));
        case ExprType::VARIABLE:
            return visitVariableExpr(static_cast<const VariableExpr*>(expr));
        case ExprType::BINARY:
            return visitBinaryExpr(static_cast<const BinaryExpr*>(expr));
        case ExprType::UNARY:
            return visitUnaryExpr(static_cast<const UnaryExpr*>(expr));
        case ExprType::GROUPING:
            return visitGroupingExpr(static_cast<const GroupingExpr*>(expr));
        case ExprType::MEMBER:
            return visitMemberExpr(static_cast<const MemberExpr*>(expr));
        case ExprType::CALL:
            return visitCallExpr(static_cast<const CallExpr*>(expr));
        case ExprType::ASSIGN:
            return visitAssignExpr(static_cast<const AssignExpr*>(expr));
    }
    return Value(nullptr);
}

Value VM::visitLiteralExpr(const LiteralExpr* expr) {
    switch (expr->valueType) {
        case LiteralValueType::NIL:
            return Value(nullptr);
        case LiteralValueType::BOOLEAN: {
            auto boolPtr = std::static_pointer_cast<bool>(expr->value);
            return Value(*boolPtr);
        }
        case LiteralValueType::NUMBER: {
            auto numPtr = std::static_pointer_cast<double>(expr->value);
            return Value(*numPtr);
        }
        case LiteralValueType::STRING: {
            auto strPtr = std::static_pointer_cast<std::string>(expr->value);
            return Value(*strPtr);
        }
    }
    return Value(nullptr);
}

Value VM::visitVariableExpr(const VariableExpr* expr) {
    return environment->get(expr->name.lexeme);
}

Value VM::visitBinaryExpr(const BinaryExpr* expr) {
    Value left = evaluate(expr->left.get());
    Value right = evaluate(expr->right.get());

    switch (expr->op.type) {
        case TokenType::PLUS:
            if (left.type == ValueType::STRING) {
                return Value(*left.as.string + right.toString());
            } else if (left.type == ValueType::NUMBER && right.type == ValueType::NUMBER) {
                return Value(left.as.number + right.as.number);
            }
            throw std::runtime_error("Operands must be two numbers or two strings.");

        case TokenType::MINUS:
            if (left.type == ValueType::NUMBER && right.type == ValueType::NUMBER) {
                return Value(left.as.number - right.as.number);
            }
            throw std::runtime_error("Operands must be numbers.");

        case TokenType::STAR:
            if (left.type == ValueType::NUMBER && right.type == ValueType::NUMBER) {
                return Value(left.as.number * right.as.number);
            }
            throw std::runtime_error("Operands must be numbers.");

        case TokenType::SLASH:
            if (left.type == ValueType::NUMBER && right.type == ValueType::NUMBER) {
                if (right.as.number == 0) {
                    throw std::runtime_error("Division by zero.");
                }
                return Value(left.as.number / right.as.number);
            }
            throw std::runtime_error("Operands must be numbers.");

        case TokenType::EQUAL_EQUAL:
            if (left.type == ValueType::NIL && right.type == ValueType::NIL) {
                return Value(true);
            } else if (left.type == ValueType::NIL || right.type == ValueType::NIL) {
                return Value(false);
            } else if (left.type == ValueType::BOOLEAN && right.type == ValueType::BOOLEAN) {
                return Value(left.as.boolean == right.as.boolean);
            } else if (left.type == ValueType::NUMBER && right.type == ValueType::NUMBER) {
                return Value(left.as.number == right.as.number);
            } else if (left.type == ValueType::STRING && right.type == ValueType::STRING) {
                return Value(*left.as.string == *right.as.string);
            }
            return Value(false);

        case TokenType::BANG_EQUAL:
            if (left.type == ValueType::NIL && right.type == ValueType::NIL) {
                return Value(false);
            } else if (left.type == ValueType::NIL || right.type == ValueType::NIL) {
                return Value(true);
            } else if (left.type == ValueType::BOOLEAN && right.type == ValueType::BOOLEAN) {
                return Value(left.as.boolean != right.as.boolean);
            } else if (left.type == ValueType::NUMBER && right.type == ValueType::NUMBER) {
                return Value(left.as.number != right.as.number);
            } else if (left.type == ValueType::STRING && right.type == ValueType::STRING) {
                return Value(*left.as.string != *right.as.string);
            }
            return Value(true);

        case TokenType::GREATER:
            if (left.type == ValueType::NUMBER && right.type == ValueType::NUMBER) {
                return Value(left.as.number > right.as.number);
            }
            throw std::runtime_error("Operands must be numbers.");

        case TokenType::GREATER_EQUAL:
            if (left.type == ValueType::NUMBER && right.type == ValueType::NUMBER) {
                return Value(left.as.number >= right.as.number);
            }
            throw std::runtime_error("Operands must be numbers.");

        case TokenType::LESS:
            if (left.type == ValueType::NUMBER && right.type == ValueType::NUMBER) {
                return Value(left.as.number < right.as.number);
            }
            throw std::runtime_error("Operands must be numbers.");

        case TokenType::LESS_EQUAL:
            if (left.type == ValueType::NUMBER && right.type == ValueType::NUMBER) {
                return Value(left.as.number <= right.as.number);
            }
            throw std::runtime_error("Operands must be numbers.");

        default:
            throw std::runtime_error("Unknown operator.");
    }
}

Value VM::visitUnaryExpr(const UnaryExpr* expr) {
    Value right = evaluate(expr->right.get());
    
    switch (expr->op.type) {
        case TokenType::MINUS:
            if (right.type == ValueType::NUMBER) {
                return Value(-right.as.number);
            }
            throw std::runtime_error("Operand must be a number.");
            
        case TokenType::BANG:
            return Value(!isTruthy(right));
            
        default:
            throw std::runtime_error("Unknown operator.");
    }
}

Value VM::visitGroupingExpr(const GroupingExpr* expr) {
    return evaluate(expr->expression.get());
}

Value VM::visitMemberExpr(const MemberExpr* expr) {
    if (expr->object->type == ExprType::VARIABLE) {
        const VariableExpr* varExpr = static_cast<const VariableExpr*>(expr->object.get());
        Value module = environment->get(varExpr->name.lexeme);
        if (module.type == ValueType::MODULE) {
            return module.as.module->get(expr->property.lexeme);
        }
    }

    throw std::runtime_error("Only modules support member access.");
}

void VM::visitExpressionStmt(const ExpressionStmt* stmt) {
    evaluate(stmt->expression.get());
}

void VM::visitPrintStmt(const PrintStmt* stmt) {
    Value value = evaluate(stmt->expression.get());
    std::cout << value.toString() << std::endl;
}

void VM::visitVarStmt(const VarStmt* stmt) {
    Value value;
    if (stmt->initializer) {
        value = evaluate(stmt->initializer.get());
    } else {
        value = Value(nullptr);
    }
    environment->define(stmt->name.lexeme, value);
}

void VM::visitBlockStmt(const BlockStmt* stmt) {
    executeBlock(stmt->statements, std::make_shared<Environment>(environment));
}

void VM::visitIfStmt(const IfStmt* stmt) {
    Value condition = evaluate(stmt->condition.get());
    
    if (isTruthy(condition)) {
        execute(stmt->thenBranch.get());
    } else if (stmt->elseBranch) {
        execute(stmt->elseBranch.get());
    }
}

void VM::visitWhileStmt(const WhileStmt* stmt) {
    while (isTruthy(evaluate(stmt->condition.get()))) {
        execute(stmt->body.get());
    }
}

void VM::visitImportStmt(const ImportStmt* stmt) {
    std::string moduleName = stmt->library.lexeme;
    if (environment->values.find(moduleName) != environment->values.end()) {
        return;
    }

    std::string filePath = "lib/" + moduleName + ".nt";

    std::ifstream file(filePath);
    if (!file.is_open()) {
        throw std::runtime_error("Could not open library file: " + filePath);
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string source = buffer.str();

    Scanner scanner(source);
    std::vector<Token> tokens = scanner.scanTokens();

    Parser parser(tokens);
    std::vector<std::unique_ptr<Stmt>> statements = parser.parse();

    auto libraryEnv = std::make_shared<Environment>();
    
    // If this is the convert module, add the native functions to the environment
    if (moduleName == "convert") {
        libraryEnv->define("char_to_int", Value(new NativeFn(native_char_to_int, 1)));
        libraryEnv->define("int_to_char", Value(new NativeFn(native_int_to_char, 1)));
        libraryEnv->define("string_get_char_at", Value(new NativeFn(native_string_get_char_at, 2)));
        libraryEnv->define("string_length", Value(new NativeFn(native_string_length, 1)));
    }

    VM libraryVM;
    libraryVM.environment = libraryEnv;
    libraryVM.interpret(statements, libraryEnv);

    auto module = new Module(moduleName, libraryEnv);
    environment->define(moduleName, Value(module));
}

void VM::visitFunctionStmt(const FunctionStmt* stmt) {
    auto function = new Function(stmt, environment);
    environment->define(stmt->name.lexeme, Value(function));
}

void VM::visitReturnStmt(const ReturnStmt* stmt) {
    Value value = nullptr;
    if (stmt->value) {
        value = evaluate(stmt->value.get());
    }
    throw Return(value);
}

Value VM::visitCallExpr(const CallExpr* expr) {
    Value callee = evaluate(expr->callee.get());

    std::vector<Value> arguments;
    for (const auto& arg : expr->arguments) {
        arguments.push_back(evaluate(arg.get()));
    }

    if (callee.type != ValueType::FUNCTION) {
        throw std::runtime_error("Can only call functions and classes.");
    }

    Callable* function = callee.as.function;
    if (arguments.size() != (size_t)function->arity()) {
        throw std::runtime_error("Expected " + std::to_string(function->arity()) + " arguments but got " + std::to_string(arguments.size()) + ".");
    }

    return function->call(*this, arguments);
}

Value VM::visitAssignExpr(const AssignExpr* expr) {
    Value value = evaluate(expr->value.get());
    environment->assign(expr->name.lexeme, value);
    return value;
}

} // namespace neutron
